diff --git a/node_modules/intermock/bin/src/lang/ts/intermock.d.ts b/node_modules/intermock/bin/src/lang/ts/intermock.d.ts
index 1fefe1a..c8cd80d 100644
--- a/node_modules/intermock/bin/src/lang/ts/intermock.d.ts
+++ b/node_modules/intermock/bin/src/lang/ts/intermock.d.ts
@@ -8,6 +8,7 @@ export interface Options {
     isFixedMode?: boolean;
     output?: OutputType;
     isOptionalAlwaysEnabled?: boolean;
+    count?: number;
 }
 declare type SupportedLanguage = 'typescript';
 export declare type OutputType = 'object' | 'json' | 'string';
diff --git a/node_modules/intermock/bin/src/lang/ts/intermock.js b/node_modules/intermock/bin/src/lang/ts/intermock.js
index 150f055..d2b3052 100644
--- a/node_modules/intermock/bin/src/lang/ts/intermock.js
+++ b/node_modules/intermock/bin/src/lang/ts/intermock.js
@@ -577,14 +577,25 @@ function setEnum(sourceFile, output, types, typeName, property) {
  * @param path Optional specific path to write to on the output object
  */
 function traverseInterface(node, output, sourceFile, options, types, propToTraverse, path) {
+    let nextIndex; 
     if (path) {
-        output[path] = {};
+        if (!output[path]) {
+          output[path] = [];
+        }
         output = output[path];
+        nextIndex = output.length;
+        output[nextIndex] = {};
+        output = output[nextIndex];
     }
     if (!propToTraverse && !path) {
         const newPath = node.name.text;
-        output[newPath] = {};
+        if (!output[newPath]) {
+          output[newPath] = [];
+        }
         output = output[newPath];
+        nextIndex = output.length;
+        output[nextIndex] = {};
+        output = output[nextIndex];
     }
     const heritageClauses = node.heritageClauses;
     const extensions = [];
@@ -600,7 +611,7 @@ function traverseInterface(node, output, sourceFile, options, types, propToTrave
                 const extensionNode = types[extensionType].node;
                 let extensionOutput = {};
                 traverseInterface(extensionNode, extensionOutput, sourceFile, options, types, propToTraverse, path);
-                extensionOutput = extensionOutput[extensionType];
+                extensionOutput = extensionOutput[extensionType][0];
                 extensions.push(extensionOutput);
             });
         });
@@ -646,11 +657,15 @@ function processFile(sourceFile, output, options, types, propToTraverse) {
                 }
                 if (propToTraverse) {
                     if (p === propToTraverse) {
-                        traverseInterface(node, output, sourceFile, options, types, propToTraverse);
+                      for (let index = 0; index < options.count; index++) {
+                          traverseInterface(node, output, sourceFile, options, types, propToTraverse);
+                      }
                     }
                 }
                 else {
-                    traverseInterface(node, output, sourceFile, options, types);
+                    for (let index = 0; index < options.count; index++) {
+                        traverseInterface(node, output, sourceFile, options, types);
+                    }
                 }
                 break;
             case typescript_1.default.SyntaxKind.TypeAliasDeclaration:
@@ -661,11 +676,15 @@ function processFile(sourceFile, output, options, types, propToTraverse) {
                 }
                 if (propToTraverse) {
                     if (path === propToTraverse) {
-                        traverseInterface(type, output, sourceFile, options, types, propToTraverse);
+                        for (let index = 0; index < options.count; index++) {
+                            traverseInterface(type, output, sourceFile, options, types, propToTraverse);
+                        }
                     }
                 }
                 else {
-                    traverseInterface(type, output, sourceFile, options, types, undefined, path);
+                    for (let index = 0; index < options.count; index++) {
+                        traverseInterface(type, output, sourceFile, options, types, undefined, path);
+                    }
                 }
                 break;
             default:
@@ -744,6 +763,9 @@ function mock(options) {
     if (!fileContents) {
         return {};
     }
+    if (!options.count) {
+      options.count = 1;
+    }
     const types = fileContents.reduce((sum, f) => {
         const type = gatherTypes(typescript_1.default.createSourceFile(f[0], f[1], typescript_1.default.ScriptTarget.ES2015, true));
         return Object.assign(Object.assign({}, sum), type);
diff --git a/node_modules/intermock/build/src/lang/ts/intermock.d.ts b/node_modules/intermock/build/src/lang/ts/intermock.d.ts
index 1fefe1a..c8cd80d 100644
--- a/node_modules/intermock/build/src/lang/ts/intermock.d.ts
+++ b/node_modules/intermock/build/src/lang/ts/intermock.d.ts
@@ -8,6 +8,7 @@ export interface Options {
     isFixedMode?: boolean;
     output?: OutputType;
     isOptionalAlwaysEnabled?: boolean;
+    count?: number;
 }
 declare type SupportedLanguage = 'typescript';
 export declare type OutputType = 'object' | 'json' | 'string';
diff --git a/node_modules/intermock/build/src/lang/ts/intermock.js b/node_modules/intermock/build/src/lang/ts/intermock.js
index 150f055..db2348e 100644
--- a/node_modules/intermock/build/src/lang/ts/intermock.js
+++ b/node_modules/intermock/build/src/lang/ts/intermock.js
@@ -577,14 +577,25 @@ function setEnum(sourceFile, output, types, typeName, property) {
  * @param path Optional specific path to write to on the output object
  */
 function traverseInterface(node, output, sourceFile, options, types, propToTraverse, path) {
+    let nextIndex; 
     if (path) {
-        output[path] = {};
+        if (!output[path]) {
+          output[path] = [];
+        }
         output = output[path];
+        nextIndex = output.length;
+        output[nextIndex] = {};
+        output = output[nextIndex];
     }
     if (!propToTraverse && !path) {
         const newPath = node.name.text;
-        output[newPath] = {};
+        if (!output[newPath]) {
+          output[newPath] = [];
+        }
         output = output[newPath];
+        nextIndex = output.length;
+        output[nextIndex] = {};
+        output = output[nextIndex];
     }
     const heritageClauses = node.heritageClauses;
     const extensions = [];
@@ -600,7 +611,7 @@ function traverseInterface(node, output, sourceFile, options, types, propToTrave
                 const extensionNode = types[extensionType].node;
                 let extensionOutput = {};
                 traverseInterface(extensionNode, extensionOutput, sourceFile, options, types, propToTraverse, path);
-                extensionOutput = extensionOutput[extensionType];
+                extensionOutput = extensionOutput[extensionType][0];
                 extensions.push(extensionOutput);
             });
         });
@@ -646,11 +657,15 @@ function processFile(sourceFile, output, options, types, propToTraverse) {
                 }
                 if (propToTraverse) {
                     if (p === propToTraverse) {
-                        traverseInterface(node, output, sourceFile, options, types, propToTraverse);
+                      for (let index = 0; index < options.count; index++) {
+                          traverseInterface(node, output, sourceFile, options, types, propToTraverse);
+                      }
                     }
                 }
                 else {
-                    traverseInterface(node, output, sourceFile, options, types);
+                  for (let index = 0; index < options.count; index++) {
+                      traverseInterface(node, output, sourceFile, options, types);
+                  }
                 }
                 break;
             case typescript_1.default.SyntaxKind.TypeAliasDeclaration:
@@ -661,11 +676,15 @@ function processFile(sourceFile, output, options, types, propToTraverse) {
                 }
                 if (propToTraverse) {
                     if (path === propToTraverse) {
-                        traverseInterface(type, output, sourceFile, options, types, propToTraverse);
+                      for (let index = 0; index < options.count; index++) {
+                          traverseInterface(type, output, sourceFile, options, types, propToTraverse);
+                      }
                     }
                 }
                 else {
-                    traverseInterface(type, output, sourceFile, options, types, undefined, path);
+                  for (let index = 0; index < options.count; index++) {
+                      traverseInterface(type, output, sourceFile, options, types, undefined, path);
+                  }
                 }
                 break;
             default:
@@ -744,6 +763,9 @@ function mock(options) {
     if (!fileContents) {
         return {};
     }
+    if (!options.count) {
+      options.count = 1;
+    }
     const types = fileContents.reduce((sum, f) => {
         const type = gatherTypes(typescript_1.default.createSourceFile(f[0], f[1], typescript_1.default.ScriptTarget.ES2015, true));
         return Object.assign(Object.assign({}, sum), type);
